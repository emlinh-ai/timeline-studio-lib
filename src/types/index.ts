import React, { CSSProperties } from 'react';

/**
 * @fileoverview Core TypeScript interfaces and types for the React Timeline Library
 */

// ============================================================================
// CORE DATA TYPES
// ============================================================================

/**
 * Represents a media clip on the timeline.
 * 
 * @example
 * ```typescript
 * const videoClip: Clip = {
 *   id: 'clip-1',
 *   trackId: 'video-track',
 *   start: 0,
 *   duration: 5.5,
 *   type: 'video',
 *   metadata: {
 *     name: 'Intro Video',
 *     thumbnailUrl: 'https://example.com/thumb.jpg',
 *     speed: 1.0
 *   }
 * };
 * ```
 */
export interface Clip {
  /** Unique identifier for the clip */
  id: string;
  
  /** ID of the track this clip belongs to */
  trackId: string;
  
  /** Start time of the clip in seconds */
  start: number;
  
  /** Duration of the clip in seconds */
  duration: number;
  
  /** Type of media clip */
  type: 'video' | 'audio' | 'text' | 'overlay';
  
  /** Optional metadata specific to clip type */
  metadata?: {
    /** Playback speed multiplier (1.0 = normal speed) */
    speed?: number;
    
    /** Whether this clip was generated by AI */
    isAI?: boolean;
    
    /** Display name for the clip */
    name?: string;
    
    /** Audio waveform data for audio clips (normalized 0-1) */
    waveform?: number[];
    
    /** Thumbnail image URL for video clips */
    thumbnailUrl?: string;
    
    /** Text content for text clips */
    text?: string;
    
    /** CSS styles for overlay clips */
    style?: CSSProperties;
  };
}

/**
 * Represents a track that contains clips.
 * 
 * @example
 * ```typescript
 * const videoTrack: Track = {
 *   id: 'video-track-1',
 *   type: 'video',
 *   name: 'Main Video',
 *   height: 80,
 *   isVisible: true,
 *   clips: [videoClip1, videoClip2]
 * };
 * ```
 */
export interface Track {
  /** Unique identifier for the track */
  id: string;
  
  /** Type of track determining what clips it can contain */
  type: 'video' | 'audio' | 'text' | 'overlay';
  
  /** Display name for the track */
  name: string;
  
  /** Height of the track in pixels */
  height: number;
  
  /** Whether the track is visible in the timeline */
  isVisible: boolean;
  
  /** Whether audio tracks are muted (audio tracks only) */
  isMuted?: boolean;
  
  /** Array of clips contained in this track */
  clips: Clip[];
}

/**
 * Complete state of the timeline component.
 * 
 * @example
 * ```typescript
 * const timelineState: TimelineState = {
 *   tracks: [videoTrack, audioTrack],
 *   currentTime: 5.5,
 *   duration: 30,
 *   zoom: 1.5,
 *   selectedClipId: 'clip-1',
 *   isPlaying: false
 * };
 * ```
 */
export interface TimelineState {
  /** Array of all tracks in the timeline */
  tracks: Track[];
  
  /** Current playhead position in seconds */
  currentTime: number;
  
  /** Total duration of the timeline in seconds */
  duration: number;
  
  /** Current zoom level (1.0 = default) */
  zoom: number;
  
  /** ID of the currently selected clip, if any */
  selectedClipId?: string;
  
  /** Whether the timeline is currently playing */
  isPlaying: boolean;
}

// ============================================================================
// EVENT SYSTEM TYPES
// ============================================================================

/**
 * Type definitions for all events emitted by the timeline.
 * Used with the event bus system for external communication.
 * 
 * @example
 * ```typescript
 * // Listen to clip click events
 * eventBus.on('timeline:clipClick', (payload) => {
 *   console.log(`Clip ${payload.clipId} clicked at ${payload.time}s`);
 * });
 * 
 * // Emit a scroll command
 * eventBus.emit('timeline:scrollTo', { time: 10 });
 * ```
 */
export interface TimelineEventPayloads {
  /** Emitted when a clip is clicked */
  'timeline:clipClick': {
    /** ID of the clicked clip */
    clipId: string;
    /** Time position where the click occurred */
    time: number;
    /** Original mouse event */
    nativeEvent: MouseEvent;
  };
  
  /** Emitted when the timeline is scrolled */
  'timeline:scroll': {
    /** Current time at the center of the viewport */
    currentTime: number;
    /** Horizontal scroll position in pixels */
    scrollLeft: number;
  };
  
  /** Emitted when the timeline zoom changes */
  'timeline:zoom': {
    /** Previous zoom level */
    oldScale: number;
    /** New zoom level */
    newScale: number;
    /** Time position to center zoom around */
    centerTime?: number;
  };
  
  /** Emitted when any timeline state changes */
  'timeline:stateChange': TimelineState;
  
  /** Emitted when timeline is fully initialized */
  'timeline:ready': void;
  
  /** Command to add a new clip */
  'timeline:addClip': { 
    /** Clip to add to the timeline */
    clip: Clip 
  };
  
  /** Command to remove a clip */
  'timeline:removeClip': { 
    /** ID of clip to remove */
    clipId: string 
  };
  
  /** Command to update clip properties */
  'timeline:updateClip': { 
    /** ID of clip to update */
    clipId: string; 
    /** Partial clip data to merge */
    updates: Partial<Clip> 
  };
  
  /** Command to scroll to a specific time */
  'timeline:scrollTo': { 
    /** Time in seconds to scroll to */
    time: number 
  };
  
  /** Command to set zoom level */
  'timeline:setZoom': { 
    /** New zoom level */
    zoom: number 
  };
  
  /** Command to zoom in */
  'timeline:zoomIn': { 
    /** Zoom factor (default: 1.2) */
    factor?: number 
  };
  
  /** Command to zoom out */
  'timeline:zoomOut': { 
    /** Zoom factor (default: 0.8) */
    factor?: number 
  };
  
  /** Command to zoom to fit all content */
  'timeline:zoomToFit': void;
  
  /** Command to zoom to a time selection */
  'timeline:zoomToSelection': { 
    /** Start time of selection */
    startTime: number; 
    /** End time of selection */
    endTime: number 
  };
  
  /** Command to undo last action */
  'timeline:undo': void;
  
  /** Command to redo last undone action */
  'timeline:redo': void;
  
  /** Emitted when undo availability changes */
  'timeline:canUndo': { 
    /** Whether undo is available */
    value: boolean 
  };
  
  /** Emitted when redo availability changes */
  'timeline:canRedo': { 
    /** Whether redo is available */
    value: boolean 
  };
  
  /** Command to export current state */
  'timeline:exportState': void;
  
  /** Emitted with exported state data */
  'timeline:stateExported': { 
    /** Serialized timeline state */
    state: TimelineState 
  };
  
  /** Command to import state data */
  'timeline:importState': { 
    /** State data to import */
    state: TimelineState 
  };
  
  /** Emitted when virtualization range changes */
  'timeline:virtualization:rangeChange': {
    /** First visible item index */
    startIndex: number;
    /** Last visible item index */
    endIndex: number;
    /** Total number of items */
    totalItems: number;
    /** Number of rendered items */
    renderedItems: number;
  };
  
  /** Emitted with render performance metrics */
  'timeline:performance:render': {
    /** Time taken to render in milliseconds */
    renderTime: number;
    /** Number of visible items */
    visibleItems: number;
    /** Total number of items */
    totalItems: number;
  };
  
  /** Emitted when context menu should be shown */
  'timeline:contextMenu': {
    /** X coordinate for menu */
    x: number;
    /** Y coordinate for menu */
    y: number;
  };
  
  /** Emitted during touch scrolling */
  'timeline:touchScroll': {
    /** Current time at center of viewport */
    currentTime: number;
    /** Horizontal scroll position */
    scrollLeft: number;
  };
}

// ============================================================================
// THEME SYSTEM TYPES
// ============================================================================

/**
 * Theme configuration for customizing timeline appearance.
 * 
 * @example
 * ```typescript
 * const darkTheme: TimelineTheme = {
 *   primaryColor: '#ff6b6b',
 *   backgroundColor: '#1a1a1a',
 *   trackBackgroundColor: '#2d2d2d',
 *   clipBorderRadius: '8px',
 *   clipColors: {
 *     video: '#4ecdc4',
 *     audio: '#45b7d1',
 *     text: '#f9ca24',
 *     overlay: '#6c5ce7'
 *   },
 *   fonts: {
 *     primary: 'Inter, sans-serif',
 *     monospace: 'JetBrains Mono, monospace'
 *   }
 * };
 * ```
 */
export interface TimelineTheme {
  /** Primary accent color used for selections and highlights */
  primaryColor: string;
  
  /** Main background color of the timeline */
  backgroundColor: string;
  
  /** Background color for individual tracks */
  trackBackgroundColor: string;
  
  /** Border radius for clips (CSS value) */
  clipBorderRadius: string;
  
  /** Colors for different clip types */
  clipColors: {
    /** Color for video clips */
    video: string;
    /** Color for audio clips */
    audio: string;
    /** Color for text clips */
    text: string;
    /** Color for overlay clips */
    overlay: string;
  };
  
  /** Font families used in the timeline */
  fonts: {
    /** Primary font for UI text */
    primary: string;
    /** Monospace font for time displays */
    monospace: string;
  };
}

/**
 * Utility type for partial theme customization.
 * Allows deep partial updates to theme objects.
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// ============================================================================
// COMPONENT PROPS TYPES
// ============================================================================

/**
 * Props passed to custom clip renderer components.
 * 
 * @example
 * ```typescript
 * const CustomClipRenderer = ({ clip, isSelected, onSelect }: ClipRendererProps) => (
 *   <div 
 *     className={`custom-clip ${isSelected ? 'selected' : ''}`}
 *     onClick={() => onSelect(clip.id)}
 *   >
 *     {clip.metadata?.name || clip.id}
 *   </div>
 * );
 * ```
 */
export interface ClipRendererProps {
  /** The clip data to render */
  clip: Clip;
  
  /** Whether this clip is currently selected */
  isSelected: boolean;
  
  /** Callback to select this clip */
  onSelect: (clipId: string) => void;
  
  /** Callback when clip is dragged to new position */
  onDrag: (clipId: string, newStart: number) => void;
  
  /** Callback when clip is resized */
  onResize: (clipId: string, newDuration: number) => void;
  
  /** CSS styles applied to the clip container */
  style: CSSProperties;
}

/**
 * Props for the main Timeline component.
 * 
 * @example
 * ```typescript
 * const timelineProps: TimelineProps = {
 *   tracks: myTracks,
 *   duration: 60,
 *   currentTime: 0,
 *   zoom: 1,
 *   enableVirtualization: true,
 *   onClipClick: (payload) => console.log('Clip clicked:', payload),
 *   theme: { primaryColor: '#ff6b6b' }
 * };
 * ```
 */
export interface TimelineProps {
  // ========================================
  // DATA PROPS
  // ========================================
  
  /** Array of tracks to display in the timeline */
  tracks?: Track[];
  
  /** Total duration of the timeline in seconds */
  duration?: number;
  
  /** Current playhead position in seconds */
  currentTime?: number;
  
  // ========================================
  // CONFIGURATION PROPS
  // ========================================
  
  /** Current zoom level (1.0 = default) */
  zoom?: number;
  
  /** Number of pixels per second at zoom level 1.0 */
  pixelsPerSecond?: number;
  
  /** Default height for tracks in pixels */
  trackHeight?: number;
  
  /** Minimum allowed zoom level */
  minZoom?: number;
  
  /** Maximum allowed zoom level */
  maxZoom?: number;
  
  // ========================================
  // EVENT BUS PROPS
  // ========================================
  
  /** Namespace for event bus communication (enables multiple timeline instances) */
  eventBusNamespace?: string;
  
  // ========================================
  // CUSTOMIZATION PROPS
  // ========================================
  
  /** Custom theme configuration (deep partial merge with default theme) */
  theme?: DeepPartial<TimelineTheme>;
  
  /** Custom clip renderer component */
  renderClip?: (props: ClipRendererProps) => React.ReactNode;
  
  /** Additional CSS class name for the timeline container */
  className?: string;
  
  // ========================================
  // FEATURE PROPS
  // ========================================
  
  /** Enable virtualization for large datasets (recommended for 100+ clips) */
  enableVirtualization?: boolean;
  
  /** Estimated size of virtualized items for performance optimization */
  estimatedItemSize?: number;
  
  /** Disable touch gestures (useful for desktop-only applications) */
  disableTouch?: boolean;
  
  /** Enable undo/redo functionality */
  enableUndo?: boolean;
  
  // ========================================
  // CALLBACK PROPS (Alternative to Event Bus)
  // ========================================
  
  /** Called when a clip is clicked */
  onClipClick?: (payload: TimelineEventPayloads['timeline:clipClick']) => void;
  
  /** Called when the timeline is scrolled */
  onScroll?: (payload: TimelineEventPayloads['timeline:scroll']) => void;
  
  /** Called when the zoom level changes */
  onZoom?: (payload: TimelineEventPayloads['timeline:zoom']) => void;
  
  /** Called when any timeline state changes */
  onStateChange?: (payload: TimelineEventPayloads['timeline:stateChange']) => void;
}

// ============================================================================
// INTERNAL STATE TYPES
// ============================================================================

/**
 * Internal state structure used by the Timeline component.
 * This extends the public TimelineState with additional UI and performance data.
 * 
 * @internal
 */
export interface InternalTimelineState {
  // Core Data
  tracks: Track[];
  currentTime: number;
  duration: number;
  
  // UI State
  zoom: number;
  scrollLeft: number;
  selectedClipId?: string;
  dragState?: {
    clipId: string;
    startX: number;
    startTime: number;
    isDragging: boolean;
  };
  
  // History for Undo/Redo
  history: {
    past: TimelineState[];
    present: TimelineState;
    future: TimelineState[];
  };
  
  // Performance
  virtualization: {
    startIndex: number;
    endIndex: number;
    itemSizes: Map<string, number>;
  };
}

// ============================================================================
// VIRTUALIZATION TYPES
// ============================================================================

/**
 * Configuration for timeline virtualization.
 * Used internally to optimize rendering of large datasets.
 * 
 * @internal
 */
export interface VirtualizationConfig {
  /** Height of each virtualized item in pixels */
  itemHeight: number;
  
  /** Number of items to render outside the visible viewport for smooth scrolling */
  overscan: number;
  
  /** Estimated size of items for initial calculations */
  estimatedItemSize: number;
  
  /** Whether all items have the same fixed size */
  useFixedSize: boolean;
}

// ============================================================================
// ERROR HANDLING TYPES
// ============================================================================

/**
 * Error thrown when data validation fails.
 * 
 * @example
 * ```typescript
 * try {
 *   validateClip(clipData);
 * } catch (error) {
 *   if (error instanceof ValidationError) {
 *     console.log(`Invalid ${error.field}: ${error.value}`);
 *   }
 * }
 * ```
 */
export class ValidationError extends Error {
  constructor(message: string, public field: string, public value: unknown) {
    super(message);
    this.name = 'ValidationError';
  }
}

/**
 * Error thrown when component rendering fails.
 * Used by error boundaries to provide context about render failures.
 */
export class RenderError extends Error {
  constructor(message: string, public componentName: string) {
    super(message);
    this.name = 'RenderError';
  }
}

/**
 * Error thrown when event bus operations fail.
 * Includes the event name that caused the failure.
 */
export class EventBusError extends Error {
  constructor(message: string, public eventName: string) {
    super(message);
    this.name = 'EventBusError';
  }
}

/**
 * Available error recovery actions for error boundaries.
 * Used to determine how to handle different types of errors.
 */
export enum ErrorRecoveryAction {
  /** Retry the failed operation */
  RETRY = 'retry',
  
  /** Reset timeline state to initial values */
  RESET_STATE = 'reset_state',
  
  /** Use fallback rendering mode */
  FALLBACK_RENDER = 'fallback_render',
  
  /** Show error message to user */
  NOTIFY_USER = 'notify_user'
}

// ============================================================================
// EVENT BUS INTERFACE TYPES
// ============================================================================

/**
 * Generic event listener function type.
 * 
 * @template T - The type of payload the listener expects
 */
export type EventListener<T = unknown> = (payload: T) => void;

/**
 * Interface for event bus implementations.
 * Provides type-safe event emission and subscription.
 * 
 * @template T - Event payload type map (defaults to TimelineEventPayloads)
 * 
 * @example
 * ```typescript
 * const eventBus: EventBusInterface = new EventBus();
 * 
 * // Type-safe event listening
 * eventBus.on('timeline:clipClick', (payload) => {
 *   // payload is automatically typed as { clipId: string; time: number; nativeEvent: MouseEvent }
 *   console.log(`Clip ${payload.clipId} clicked`);
 * });
 * 
 * // Type-safe event emission
 * eventBus.emit('timeline:clipClick', {
 *   clipId: 'clip-1',
 *   time: 5.5,
 *   nativeEvent: mouseEvent
 * });
 * ```
 */
export interface EventBusInterface<T = TimelineEventPayloads> {
  /**
   * Emit an event with the specified payload.
   * 
   * @param event - Event name (must be a key of T)
   * @param payload - Event payload (must match the type for the event)
   */
  emit<K extends keyof T>(
    event: K,
    payload: T[K]
  ): void;
  
  /**
   * Subscribe to an event.
   * 
   * @param event - Event name to listen for
   * @param listener - Function to call when event is emitted
   */
  on<K extends keyof T>(
    event: K,
    listener: EventListener<T[K]>
  ): void;
  
  /**
   * Unsubscribe from an event.
   * 
   * @param event - Event name to stop listening for
   * @param listener - Specific listener function to remove
   */
  off<K extends keyof T>(
    event: K,
    listener: EventListener<T[K]>
  ): void;
  
  /**
   * Clear all event listeners.
   * Useful for cleanup when component unmounts.
   */
  clear(): void;
}